# spatch

`spatch` applies structural rewrites using a patch document.

A patch document is a text block where:

- `-` lines define what to match
- `+` lines define what to insert
- other lines are context shared by both sides

You can pass the patch document either:

- inline as a string
- as a file path

## CLI

```bash
spatch <patch-input> [scope] [--cwd <path>] [--dry-run] [--check] [--json] [--no-color] [--interactive] [--concurrency <n>] [--verbose <level>]
# or:
astkit patch <patch-input> [scope] [--cwd <path>] [--dry-run] [--check] [--json] [--no-color] [--interactive] [--concurrency <n>] [--verbose <level>]
```

Use `spatch --help` for the full flag docs generated by `stricli`.

Output modes:

- default: compact diff-style text
- `--json`: machine-readable structured result
- `--check`: CI guardrail (non-zero exit when replacements are needed)

Scope boundary:

- if `cwd` is inside a git repository, `scope` must stay within the nearest repo root
- if no git repository root is found, `scope` must stay within `cwd`

Examples:

```bash
# patch document from file
spatch rules/const-to-let.spatch src --cwd /repo

# patch document from stdin
cat rules/const-to-let.spatch | spatch - src

# inline patch document
spatch $'-const :[name] = :[value];\n+let :[name] = :[value];' src

# preview only
spatch rules/const-to-let.spatch src --dry-run

# CI guardrail: fail if rewrite is needed
spatch rules/const-to-let.spatch src --check

# structured JSON output
spatch rules/const-to-let.spatch src --json

# interactive apply mode
spatch rules/const-to-let.spatch src --interactive
```

## API

```ts
import { patchProject } from "@claudiu-ceia/spatch";

await patchProject(patchInput, {
  cwd: "/repo", // optional, default process.cwd()
  scope: "src", // file or directory, default "."
  dryRun: false, // optional, default false
  encoding: "utf8", // optional, default utf8
  concurrency: 8, // optional
  verbose: 1, // optional (1=summary, 2=slow files)
  logger: console.error, // optional
});
```

`patchInput` can be:

- a patch document string
- a path to a patch file (resolved from `cwd`)

## Patch Document Grammar

### Line kinds

- `-...`: deletion line (belongs to match pattern only)
- `+...`: addition line (belongs to replacement only)
- ` ...`: context line (belongs to both pattern and replacement)
- `\-...` and `\+...`: escaped marker lines, treated as literal context starting with `-` or `+`

### Minimum change rule

A patch document must contain at least one `-` line or one `+` line.

### Newline behavior

If the patch document ends with a trailing newline, both generated `pattern` and `replacement` preserve it.

## Metavariables

Inside pattern/replacement text, holes use this syntax:

- `:[name]`
- `:[_]` (anonymous hole, not captured)
- `:[name~regex]` (capture must satisfy regex)
- `...` (variadic wildcard; captured and reusable in replacement)

Examples:

```text
-const :[name] = :[value];
+let :[name] = :[value];
```

```text
-const :[name~[a-z]+] = :[value~\d+];
+let :[name] = Number(:[value]);
```

Repeated holes enforce equality:

```text
-:[x] + :[x];
+double(:[x]);
```

`foo + foo` matches, `foo + bar` does not.

Variadic example:

```text
-foo(:[x], ...);
+bar(:[x], ...);
```

Rewrites the callee and preserves remaining arguments.

## Interactive Safety

Interactive mode (`--interactive`) scans first in dry-run mode, then applies only selected matches.
Before applying each file, `spatch` verifies selected byte spans still match current file contents.
If a file changed during the session, apply aborts with an error instead of writing stale offsets.

## How It Works

### 1) Parse phase

`patchProject` resolves `patchInput` into a patch document and parses it into:

- `pattern`
- `replacement`

### 2) Rewrite phase

For each scoped file:

- compile template tokens from `pattern`
- find all structural matches
- render `replacement` with captures
- apply replacements
- optionally write file (skipped in `dryRun`)

### 3) Output phase

Return an aggregate result:

- files scanned/matched/changed
- match and replacement counts
- elapsed time
- per-file occurrences with spans and captures

## Structural Balancing

Hole captures are checked for structural balance to avoid malformed partial captures.

Balanced constructs supported in capture chunks:

- parentheses `(...)`
- brackets `[...]`
- braces `{...}`
- single/double/template strings
- line and block comments

## End-to-End Example

Patch document:

```text
function wrap() {
-  const value = :[value];
+  let value = :[value];
   return value;
}
```

Call:

```ts
await patchProject("rules/wrap.spatch", { cwd: "/repo", scope: "src" });
```

## Flow Diagram

```text
patchProject(patchInput, options)
  -> parsePatchInvocation
      -> resolve patch text (inline or file)
      -> parsePatchDocument (+/-/context)
  -> rewriteProject
      -> compileTemplate(pattern)
      -> collect files
      -> for each file: match -> render -> apply -> (write)
  -> buildSpatchResult
```

## Development

From monorepo root:

```bash
bun run spatch -- --help
bun run spatch -- '<patch-input>' [scope]
npm run test:spatch
npm run test:spatch:coverage
```
